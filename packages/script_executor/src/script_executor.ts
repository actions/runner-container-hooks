/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: script_executor.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from 'google-protobuf'
import * as grpc_1 from '@grpc/grpc-js'
export namespace script_executor {
  export class ScriptRequest extends pb_1.Message {
    #one_of_decls: number[][] = []
    constructor(
      data?:
        | any[]
        | {
            script?: string
            id?: string
          }
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      )
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('script' in data && data.script != undefined) {
          this.script = data.script
        }
        if ('id' in data && data.id != undefined) {
          this.id = data.id
        }
      }
    }
    get script() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string
    }
    set script(value: string) {
      pb_1.Message.setField(this, 1, value)
    }
    get id() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string
    }
    set id(value: string) {
      pb_1.Message.setField(this, 2, value)
    }
    static fromObject(data: { script?: string; id?: string }): ScriptRequest {
      const message = new ScriptRequest({})
      if (data.script != null) {
        message.script = data.script
      }
      if (data.id != null) {
        message.id = data.id
      }
      return message
    }
    toObject() {
      const data: {
        script?: string
        id?: string
      } = {}
      if (this.script != null) {
        data.script = this.script
      }
      if (this.id != null) {
        data.id = this.id
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.script.length) writer.writeString(1, this.script)
      if (this.id.length) writer.writeString(2, this.id)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ScriptRequest {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new ScriptRequest()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.script = reader.readString()
            break
          case 2:
            message.id = reader.readString()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): ScriptRequest {
      return ScriptRequest.deserialize(bytes)
    }
  }
  export class ScriptResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2], [3]]
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                output?: string
              }
            | {
                error?: string
              }
            | {
                code?: number
              }
          ))
    ) {
      super()
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls
      )
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('output' in data && data.output != undefined) {
          this.output = data.output
        }
        if ('error' in data && data.error != undefined) {
          this.error = data.error
        }
        if ('code' in data && data.code != undefined) {
          this.code = data.code
        }
      }
    }
    get output() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string
    }
    set output(value: string) {
      pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value)
    }
    get has_output() {
      return pb_1.Message.getField(this, 1) != null
    }
    get error() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string
    }
    set error(value: string) {
      pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value)
    }
    get has_error() {
      return pb_1.Message.getField(this, 2) != null
    }
    get code() {
      return pb_1.Message.getFieldWithDefault(this, 3, 0) as number
    }
    set code(value: number) {
      pb_1.Message.setOneofField(this, 3, this.#one_of_decls[2], value)
    }
    get has_code() {
      return pb_1.Message.getField(this, 3) != null
    }
    get _output() {
      const cases: {
        [index: number]: 'none' | 'output'
      } = {
        0: 'none',
        1: 'output'
      }
      return cases[pb_1.Message.computeOneofCase(this, [1])]
    }
    get _error() {
      const cases: {
        [index: number]: 'none' | 'error'
      } = {
        0: 'none',
        2: 'error'
      }
      return cases[pb_1.Message.computeOneofCase(this, [2])]
    }
    get _code() {
      const cases: {
        [index: number]: 'none' | 'code'
      } = {
        0: 'none',
        3: 'code'
      }
      return cases[pb_1.Message.computeOneofCase(this, [3])]
    }
    static fromObject(data: {
      output?: string
      error?: string
      code?: number
    }): ScriptResponse {
      const message = new ScriptResponse({})
      if (data.output != null) {
        message.output = data.output
      }
      if (data.error != null) {
        message.error = data.error
      }
      if (data.code != null) {
        message.code = data.code
      }
      return message
    }
    toObject() {
      const data: {
        output?: string
        error?: string
        code?: number
      } = {}
      if (this.output != null) {
        data.output = this.output
      }
      if (this.error != null) {
        data.error = this.error
      }
      if (this.code != null) {
        data.code = this.code
      }
      return data
    }
    serialize(): Uint8Array
    serialize(w: pb_1.BinaryWriter): void
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter()
      if (this.has_output) writer.writeString(1, this.output)
      if (this.has_error) writer.writeString(2, this.error)
      if (this.has_code) writer.writeInt32(3, this.code)
      if (!w) return writer.getResultBuffer()
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ScriptResponse {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new ScriptResponse()
      while (reader.nextField()) {
        if (reader.isEndGroup()) break
        switch (reader.getFieldNumber()) {
          case 1:
            message.output = reader.readString()
            break
          case 2:
            message.error = reader.readString()
            break
          case 3:
            message.code = reader.readInt32()
            break
          default:
            reader.skipField()
        }
      }
      return message
    }
    serializeBinary(): Uint8Array {
      return this.serialize()
    }
    static deserializeBinary(bytes: Uint8Array): ScriptResponse {
      return ScriptResponse.deserialize(bytes)
    }
  }
  interface GrpcUnaryServiceInterface<P, R> {
    (
      message: P,
      metadata: grpc_1.Metadata,
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientUnaryCall
    (
      message: P,
      metadata: grpc_1.Metadata,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientUnaryCall
    (
      message: P,
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientUnaryCall
    (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall
  }
  interface GrpcStreamServiceInterface<P, R> {
    (
      message: P,
      metadata: grpc_1.Metadata,
      options?: grpc_1.CallOptions
    ): grpc_1.ClientReadableStream<R>
    (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>
  }
  interface GrpWritableServiceInterface<P, R> {
    (
      metadata: grpc_1.Metadata,
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientWritableStream<P>
    (
      metadata: grpc_1.Metadata,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientWritableStream<P>
    (
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientWritableStream<P>
    (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>
  }
  interface GrpcChunkServiceInterface<P, R> {
    (
      metadata: grpc_1.Metadata,
      options?: grpc_1.CallOptions
    ): grpc_1.ClientDuplexStream<P, R>
    (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>
  }
  interface GrpcPromiseServiceInterface<P, R> {
    (
      message: P,
      metadata: grpc_1.Metadata,
      options?: grpc_1.CallOptions
    ): Promise<R>
    (message: P, options?: grpc_1.CallOptions): Promise<R>
  }
  export abstract class UnimplementedScriptExecutorService {
    static definition = {
      ExecuteScript: {
        path: '/script_executor.ScriptExecutor/ExecuteScript',
        requestStream: false,
        responseStream: true,
        requestSerialize: (message: ScriptRequest) =>
          Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) =>
          ScriptRequest.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: ScriptResponse) =>
          Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) =>
          ScriptResponse.deserialize(new Uint8Array(bytes))
      }
    };
    [method: string]: grpc_1.UntypedHandleCall
    abstract ExecuteScript(
      call: grpc_1.ServerWritableStream<ScriptRequest, ScriptResponse>
    ): void
  }
  export class ScriptExecutorClient extends grpc_1.makeGenericClientConstructor(
    UnimplementedScriptExecutorService.definition,
    'ScriptExecutor',
    {}
  ) {
    constructor(
      address: string,
      credentials: grpc_1.ChannelCredentials,
      options?: Partial<grpc_1.ChannelOptions>
    ) {
      super(address, credentials, options)
    }
    ExecuteScript: GrpcStreamServiceInterface<ScriptRequest, ScriptResponse> = (
      message: ScriptRequest,
      metadata?: grpc_1.Metadata | grpc_1.CallOptions,
      options?: grpc_1.CallOptions
    ): grpc_1.ClientReadableStream<ScriptResponse> => {
      return super.ExecuteScript(message, metadata, options)
    }
  }
}
